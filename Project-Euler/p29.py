# Consider all integer combinations of a^(b) for 2 <= a <= 5 and 2 <= b <= 5:

#     2^(2)=4, 2^(3)=8, 2^(4)=16, 2^(5)=32
#     3^(2)=9, 3^(3)=27, 3^(4)=81, 3^(5)=243
#     4^(2)=16, 4^(3)=64, 4^(4)=256, 4^(5)=1024
#     5^(2)=25, 5^(3)=125, 5^(4)=625, 5^(5)=3125

# If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:

# 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

# How many distinct terms are in the sequence generated by a^(b) for 2 <= a <= 100 and 2 <= b <= 100?

import math

primes = {}

def buildPowers(lower, number, limit):
    count = limit - lower + 1
    print number, limit, lower, count
    if not primes.has_key(number):
        primes[number] = limit - lower + 1
    elif primes[number] > count:
        primes[number] -= count

## build derived, ie from 2's powers extend to 4's etc
def buildDerived(num, limit):
    counter = 2

    ## max built my num 
    max_yet = math.pow(num, limit)

    while counter <= limit:
        pow = int(math.pow(num, counter))
        if pow > limit: break

        ## power of max built in term of 'i' (i is a power of prime)
        lower = int(math.floor(math.log(max_yet, pow))) + 1
        if (num == 2):
            print pow, lower, limit, max_yet

        ## build the rest of the powers
        buildPowers(lower, pow, limit)

        buildDerived(pow, limit)
        
        counter += 1


if __name__ == '__main__':
    LIMIT = 20

    counter = 2
    while counter <= LIMIT:
        lower = 2 # least power
        buildPowers(lower, counter, LIMIT)
        buildDerived(counter, LIMIT)

        ## add next prime number
        counter += 1

    # build derived primes (eg, 4, 8, 16 etc from 2)

    total_powers = 0
    for i in primes.keys():
        total_powers += primes[i]

    print total_powers
    print primes
